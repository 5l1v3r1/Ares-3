package com.basic.core.util;


import com.basic.core.model.ComponentPair;
import com.basic.core.model.NodePair;
import org.apache.storm.scheduler.*;
import org.apache.storm.scheduler.resource.Component;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * locate com.basic.core.util
 * Created by 79875 on 2017/10/4.
 * ComputeCostUtil 工具包
 */
public class ComputeCostUtil {
    private static final Logger LOG = LoggerFactory.getLogger(ComputeCostUtil.class);

    private static ComputeCostUtil instance;

    private TopologyDetails topology;
    private Cluster cluster;

    public static synchronized ComputeCostUtil getInstance(TopologyDetails topology, Cluster cluster) {
        instance = new ComputeCostUtil(topology,cluster);
        return instance;
    }

    private ComputeCostUtil(TopologyDetails topology, Cluster cluster) {
        this.topology = topology;
        this.cluster=cluster;
    }

    private ComputeCostUtil() {
    }

    //The parameter q denotes the computation cost for components to process a single tuple.
    private Map<String, Double> q;

    //The parameter lambda denotes the data processing time for node to process a single computation cost.
    private Map<String, Double> lambda;

    //The parameter d denotes the data transferring time of node pairs.
    private Map<NodePair, Double> d;

    //The parameter w denotes the recover time of upstream and downstream executor pairs.
    private Map<ComponentPair, Double> w;

    //The parameter alpha is generated by transforming Problem 1 into Problem 2, and varies from executors to executors.
    private Map<String, Double> alpha;

    //The parameter beta is generated by transforming Problem 1 into Problem 2, and varies from executor pairs to executor pairs.
    private Map<ComponentPair, Double> beta;

    //The parameter gamma is generated by transforming Problem 1 into Problem 2, and varies from executor pairs to executor pairs.
    private Map<ComponentPair, Double> gamma;

    //Add up all tasks' procesing time for a single slot
    public Map<WorkerSlot, Double> totalProcessingCostOfExecutorsOnSlot = new HashMap<>();

    //Number of tasks in a slot
    public Map<WorkerSlot, Integer> slotContainTaskNum=new HashMap<>();

    public void initPara(){
        q = InitParaUtils.initializeQ(topology);
        lambda = InitParaUtils.initializeLambda(cluster);
        d = InitParaUtils.initializeD(cluster);
        w = InitParaUtils.initializeW(topology);
        alpha = InitParaUtils.initializeAlpha(topology);
        beta = InitParaUtils.initializeBeta(topology);
        gamma = InitParaUtils.initializeGamma(topology,cluster);
        printAlllPara();
    }

    private void printAlllPara() {
        LOG.info("------------------parameter q-------------------");
        for(String compentId:q.keySet()){
            LOG.info(compentId+"\t"+q.get(compentId));
        }
        LOG.info("");

        LOG.info("------------------parameter lambda-------------------");
        for(String hostId:lambda.keySet()){
            LOG.info(hostId+"\t"+lambda.get(hostId));
        }
        LOG.info("");

        LOG.info("------------------parameter d-------------------");
        for(NodePair nodePair:d.keySet()){
            LOG.info(nodePair.getUpnode()+"\t"+nodePair.getDownnode()+"\t"+d.get(nodePair));
        }
        LOG.info("");

        LOG.info("------------------parameter w-------------------");
        for(ComponentPair componentPair:w.keySet()){
            LOG.info(componentPair.getUpcomponent().id+"\t"+componentPair.getdowncomponent().id+"\t"+w.get(componentPair));
        }
        LOG.info("");

        LOG.info("------------------parameter alpha-------------------");
        for(String componentId:alpha.keySet()){
            LOG.info(componentId+"\t"+alpha.get(componentId));
        }
        LOG.info("");

        LOG.info("------------------parameter beta-------------------");
        for(ComponentPair componentPair:beta.keySet()){
            LOG.info(componentPair.getUpcomponent().id+"\t"+componentPair.getdowncomponent().id+"\t"+beta.get(componentPair));
        }
        LOG.info("");

        LOG.info("------------------parameter gama-------------------");
        for(ComponentPair componentPair:gamma.keySet()){
            LOG.info(componentPair.getUpcomponent().id+"\t"+componentPair.getdowncomponent().id+"\t"+gamma.get(componentPair));
        }
        LOG.info("");
    }

    /**
     * computeDataProcessingCost 计算数据传输权值
     * @param executor
     * @param workerSlot
     * @return
     */
    private double computeDataProcessingCost( ExecutorDetails executor, WorkerSlot workerSlot){
        String currentComponentId = topology.getExecutorToComponent().get(executor);
        Component component = topology.getComponents().get(currentComponentId);
        Double componentcost = q.get(component.id);
        Double nodecomputecost = lambda.get(workslotToHost(workerSlot));
        return alpha.get(executorToComponent(executor).id)*componentcost*nodecomputecost;
    }

    /**
     * Executor To Component
     * @param executorDetails
     * @return
     */
    private Component executorToComponent(ExecutorDetails executorDetails){
        String componedtId = topology.getExecutorToComponent().get(executorDetails);
        return topology.getComponents().get(componedtId);
    }

    /**
     * workSlot To Host
     * @param workerSlot
     * @return
     */
    private String workslotToHost(WorkerSlot workerSlot){
        return cluster.getHost(workerSlot.getNodeId());
    }
    /**
     * 初始化 ExecutorOnSlot的计算时间辅助变量HashMap
     * @param slots
     * @param assignment
     */
    public void initProcessingCostMap(List<WorkerSlot> slots , Map<ExecutorDetails, WorkerSlot> assignment){
        HashMap<WorkerSlot, List<ExecutorDetails>> workerSlotsToExecutors = AresUtils.reverseMap(assignment);
        for(WorkerSlot slot: slots){
            if(workerSlotsToExecutors.containsKey(slot)){
                List<ExecutorDetails> executorDetails = workerSlotsToExecutors.get(slot);
                slotContainTaskNum.put(slot,executorDetails.size());
                Double cost=0.0;
                for(ExecutorDetails executor:executorDetails){
                    if(!AresUtils.isComponentAcker(topology,executor)){
                        cost+=computeDataProcessingCost(executor,slot);
                    }
                }
                totalProcessingCostOfExecutorsOnSlot.put(slot,cost);
            }else {
                totalProcessingCostOfExecutorsOnSlot.put(slot,0.0);
                slotContainTaskNum.put(slot,0);
            }
        }
    }

    /**
     * firstIn Delte ProcessingCost 分配后目标Slot的计算ProcessingCostMap值改变
     * @param slot
     * @param executor
     */
    public void deleteProcessingCostMap(WorkerSlot slot, ExecutorDetails executor){
        int temp = slotContainTaskNum.get(slot);
        slotContainTaskNum.put(slot,--temp);

        double cost = computeDataProcessingCost( executor, slot);
        double tempCost = totalProcessingCostOfExecutorsOnSlot.get(slot);
        tempCost-=cost;
        totalProcessingCostOfExecutorsOnSlot.put(slot,tempCost);
    }

    /**
     * firstOut Update ProcessingCost 分配后目标Slot的计算ProcessingCostMap值改变
     * @param slot
     * @param executor
     */
    public void updateProcessingCostMap(WorkerSlot slot, ExecutorDetails executor){
        int temp = slotContainTaskNum.get(slot);
        slotContainTaskNum.put(slot,++temp);

        double cost = computeDataProcessingCost( executor, slot);
        double tempCost = totalProcessingCostOfExecutorsOnSlot.get(slot);
        tempCost+=cost;
        totalProcessingCostOfExecutorsOnSlot.put(slot,tempCost);
    }

    /**
     * Topology 计算权值
     * @param executor
     * @param workerSlot
     * @return
     */
    public double computeProcessingCost(ExecutorDetails executor, WorkerSlot workerSlot){

        SupervisorDetails supervisorDetails = cluster.getSupervisors().get(workerSlot.getNodeId());
        List<WorkerSlot> allSlotsSupervisor = AresUtils.getAllSlotsSupervisor(cluster, supervisorDetails);
        double totalNodeProcessingCost=0.0;
        int nodeContaintaskNum=0;
        for(WorkerSlot slot :allSlotsSupervisor){
            totalNodeProcessingCost+=totalProcessingCostOfExecutorsOnSlot.get(slot);
            //LOG.info(slot+" "+totalProcessingCostOfExecutorsOnSlot.get(slot));
            nodeContaintaskNum+=slotContainTaskNum.get(slot);
        }
        //LOG.info("");
        //LOG.info("compentId:"+topology.getExecutorToComponent().get(executor)+" executorId:"+executor.getStartTask()+" nodeContainTaskNum:"+nodeContaintaskNum+" totalNodeProcessingCost:"+totalNodeProcessingCost);
        //LOG.info("computeDataProcessingCost:"+computeDataProcessingCost(executor,workerSlot));
        return totalNodeProcessingCost+(nodeContaintaskNum+1)*computeDataProcessingCost(executor,workerSlot);
    }

    /**
     * 计算Topology 网络传输 Cost
     * @param upexecutor
     * @param downexecutor
     * @param upslot
     * @param downslot
     * @return
     */
    public double computeTransferringCost(ExecutorDetails upexecutor, ExecutorDetails downexecutor, WorkerSlot upslot, WorkerSlot downslot){
        ComponentPair componentPair=new ComponentPair(executorToComponent(upexecutor),executorToComponent(downexecutor));
        NodePair nodePair=new NodePair(workslotToHost(upslot),workslotToHost(downslot));
        return beta.get(componentPair) * d.get(nodePair);
    }

    /**
     * 计算Topology 恢复时间 Cost
     * @param upexecutor
     * @param downexecutor
     * @return
     */
    public double computeRecoveryCost(ExecutorDetails upexecutor, ExecutorDetails downexecutor){
        ComponentPair componentPair=new ComponentPair(executorToComponent(upexecutor),executorToComponent(downexecutor));
        return gamma.get(componentPair) * w.get(componentPair);
    }

    /**
     * 计算当前assignment分配的UtilityCost
     * @param assignment
     * @return
     */
    public double computeUtilityCost( Map<ExecutorDetails, WorkerSlot> assignment){
        double utilityCost=0.0;
        double transferringCost=0.0;
        double recoveryCost=0.0;
        double computeCost=0.0;

        for(String supervisorId : cluster.getSupervisors().keySet()){
            SupervisorDetails supervisorDetails = cluster.getSupervisors().get(supervisorId);
            List<WorkerSlot> allSlotsSupervisor = AresUtils.getAllSlotsSupervisor(cluster, supervisorDetails);
            double totalNodeProcessingCost=0.0;
            int nodeContaintaskNum=0;
            for(WorkerSlot slot :allSlotsSupervisor){
                totalNodeProcessingCost+=totalProcessingCostOfExecutorsOnSlot.get(slot);
                nodeContaintaskNum+=slotContainTaskNum.get(slot);
            }
            computeCost+=totalNodeProcessingCost*nodeContaintaskNum;
        }

        for(String compentId : topology.getComponents().keySet()){
            Component component = topology.getComponents().get(compentId);
            if (component == null || component.children.size()==0) {
                continue;
            }
            for(String childId :component.children){
                Component child = topology.getComponents().get(childId);
                for(ExecutorDetails executor : component.execs)
                    for(ExecutorDetails childExecutor : child.execs){
                        transferringCost+=computeTransferringCost(executor,childExecutor,assignment.get(executor),assignment.get(childExecutor));
                        recoveryCost+=computeRecoveryCost(executor,childExecutor);
                    }
            }
        }

        utilityCost=computeCost+transferringCost+recoveryCost;
        return utilityCost;
    }
}
